class SBlock{
    field int r,c;
    field int type;	
    //the position of this one should be considered carefully | be redefined
    constructor SBlock new(Map A)
    {
        let r = 1;
        let c = 4;
        do A.set(r,c);
        do A.set(r,c+1);
        do A.set(r-1,c+1);
        do A.set(r-1, c+2);
        return this;
    }

    method void dispose() {
      do Memory.deAlloc(this);
      return;
    }

    // Put into SBlock.jack

    method void S_rotate(Map M, Block B)
    {	
	
      var int r; 
      var int c;

      let r = B.getR();
      let c = B.getC();
          
      if ((r> 0) & (c> 0) & (c< 9))
      {
        if (( M.read(r ,c)= 1 ) & ( M.read(r-1 ,c)= 1 ) & ( M.read(r-1 ,c+1)= 1 ) & ( M.read(r ,c-1)= 1 ))
          {let type= 0;}
      }

      if ((r> 0) & (r< 19) & (c> 0))
      {
        if (( M.read(r ,c)= 1 ) & ( M.read(r-1 ,c-1)= 1 ) & ( M.read(r ,c-1)= 1 ) & ( M.read(r+1 ,c)= 1 ))
          {let type= 1;}
      }

      if (type= 0)
      {	
        if (r= 19)
        {
          // cannot collide w/ others
          if (( M.read(r-2 ,c-1)= 1 ) | ( M.read(r-1 ,c-1)= 1 ))
            {return;}

          // implement
          do M.reset(r, c-1);
          do M.reset(r-1, c+1);
          do M.set(r-2, c-1);
          do M.set(r-1, c-1);

          do B.setR(18);

          // after 500ms | click down:
          // do M.reset(r-2, c-1);
          // do M.reset(r-1, c-1);
          // do M.reset(r-1, c);
          // do M.reset(r ,c);
          // do M.set(r-1, c-1);
          // do M.set(r, c-1);
          // do M.set(r, c);
          // do M.set(r+1 ,c);
          // outside loop r+1
        }
        else
        {
          // cannot collide w/ others
          if (( M.read(r-1 ,c-1)= 1 ) | ( M.read(r+1 ,c)= 1 ))
            {return;}

          // implement
          do M.reset(r-1, c);
          do M.reset(r-1, c+1);
          do M.set(r-1, c-1);
          do M.set(r+1, c);

          // after 500ms | click down:
          // do M.reset(r-1, c-1);
          // do M.reset(r, c-1);
          // do M.reset(r, c);
          // do M.reset(r+1 ,c);
          // do M.set(r, c-1);
          // do M.set(r+1, c-1);
          // do M.set(r+1, c);
          // do M.set(r+2 ,c);
          // outside loop r+1
        }
      }

      if (type= 1)
      {	
        if (c= 9)
        {
          // cannot collide w/ others
          if (( M.read(r-1 ,c)= 1 ) | ( M.read(r ,c-2)= 1 ))
            {return;}

          // implement
          do M.reset(r+1, c);
          do M.reset(r, c);
          do M.set(r-1, c);
          do M.set(r, c-2);

          do B.setC(8);

          // after 500ms | click down:
          // do M.reset(r-1, c-1);
          // do M.reset(r-1, c);
          // do M.reset(r, c-2);
          // do M.reset(r, c-1);
          // do M.set(r, c-1);
          // do M.set(r, c);
          // do M.set(r+1, c-2);
          // do M.set(r+1 ,c-1);
          // outside loop r+1
        }
        else
        {
          // cannot collide w/ others
          if (( M.read(r-1 ,c)= 1 ) | ( M.read(r-1 ,c+1)= 1 ))
            {return;}

          // implement
          do M.reset(r, c);
          do M.reset(r+1, c);
          do M.set(r-1, c);
          do M.set(r-1, c+1);

          // after 500ms | click down:
          // do M.reset(0, c-1);
          // do M.reset(1, c-1);
          // do M.reset(2, c-1);
          // do M.reset(2 ,c);
          // do M.set(1, c-1);
          // do M.set(2, c-1);
          // do M.set(3, c-1);
          // do M.set(3 ,c);
          // outside loop r+1
        }
      }
      return ;
    }
  
}