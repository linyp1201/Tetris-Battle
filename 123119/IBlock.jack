class IBlock{
    field int r,c;
    field int type;	
    constructor IBlock new(Map A)
    {
        let r = 0;
        let c = 3;
        /*do A.set(r,c);
        do A.set(r,c+1);
        do A.set(r,c+2);
        do A.set(r, c+3);*/
        return this;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    
    method void I_rotate (Map M, Block B)
    {	
        var int r; 
        var int c; 
        var int temp;
        
        let r = B.getR();
        let c = B.getC();

        if ( M.read(r,c+1) = 1 )
        {
            let type= 0;	// lying
        }	
    
        if ( M.read(r-1, c)= 1 )
        {
            let type= 1;	// standing
        }	
          
        if (type= 0)
        {	
            if (r>3)
            {
                // cannot collide w/ others

                   
                if ( ( M.read(r-1, c)= 1 ) | ( M.read(r-2, c)= 1 ) | ( M.read(r-3, c)= 1 ) )
                  {
                      return;
                  }
                // implement
                do M.reset(r, c+1);
                do M.reset(r, c+2);
                do M.reset(r, c+3);
                do M.set(r-1, c);
                do M.set(r-2, c);
                do M.set(r-3, c);  
            }
            else	// r= 0, 1, 2, 3	
            {
                // cannot collide w/ others
                //var int temp;
                let temp= r-1;
                while (temp> 0)
                {
                  if( M.read(temp, c)= 1 )
                  {let temp= temp-1;
                    return;}
                  
                }
                if (temp> 0)
                  {return;}

                // implement
                do M.reset(r, c+1);
                do M.reset(r, c+2);
                do M.reset(r, c+3);
                do M.set(0, c);
                do M.set(1, c);
                do M.set(2, c);
                do M.set(3, c);
                
                do B.setR(3);

            }
        }

        if (type= 1)
        {
            if (c< 6)
            {
                // cannot collide w/ others
                if ((( M.read(r, c+1)= 1 ) | ( M.read(r, c+2)= 1 )) | ( M.read(r, c+3)= 1 ))
                    {return;}

                // implement
                do M.reset(r-1, c);
                do M.reset(r-2, c);
                do M.reset(r-3, c);
                do M.set(r, c+1);
                do M.set(r, c+2);
                do M.set(r, c+3);


            }
            else	// c= 6, 7, 8, 9	
            {
                // cannot collide w/ others
                //var int temp;
                let temp= c+1;
                while (temp< 10)
                {
                    if( M.read(r, temp)= 1 )
                        {return;}
                    let temp= temp+1;
                }
                if (temp< 10)
                    {return;}

                // implement
                do M.reset(r-1, c);
                do M.reset(r-2, c);
                do M.reset(r-3, c);		
                do M.set(r, 6);
                do M.set(r, 7);
                do M.set(r, 8);
                do M.set(r, 9);
                
                do B.setC(6);

            }
        }
        return ;
    }


    method void left(Map M, Block B)
{
        var int r; 
	    var int c; 
        let r= B.getR();
        let c= B.getC();

	// verdict type 0 or 1
	// here
	
	if (type= 0)
	{
		if (c= 0)
		{
			return;
		}

		if ( M.read(r, c-1)= 0 )
		{
			do M.set(r, c-1);
			do M.reset(r, c+3);
			do B.setC(c-1);

		}
	}

	if (type= 1)
	{
		if (c= 0)
		{
			return;
		}

		if ( (M.read(r, c-1)= 0) & (M.read(r-1, c-1)= 0) & (M.read(r-2, c-1)= 0) & (M.read(r-3, c-1)= 0) )
		{
			do M.reset(r, c);
			do M.reset(r-1, c);
			do M.reset(r-2, c);
			do M.reset(r-3, c);
			do M.set(r, c-1);
			do M.set(r-1, c-1);
			do M.set(r-2, c-1);
			do M.set(r-3, c-1);

			do B.setC(c-1);
		}
	}
    return;
}

method void right(Map M, Block B)
{

    var int r; 
	var int c; 
        let r= B.getR();
        let c= B.getC();

	// verdict type 0 or 1
	// here
	
	if (type= 0)
	{
		if (c= 9)
		{
			return;
		}

		if ( M.read(r, c+1)= 0 )
		{
			do M.set(r, c+1);
			do M.reset(r, c-3);

			do B.setC(c+1);
		}
	}

	if (type= 1)
	{
		if (c= 9)
		{
			return;
		}

		if ( (M.read(r, c+1)= 0) & (M.read(r-1, c+1)= 0) & (M.read(r-2, c+1)= 0) & (M.read(r-3, c+1)= 0) )
		{
			do M.reset(r, c);
			do M.reset(r-1, c);
			do M.reset(r-2, c);
			do M.reset(r-3, c);
			do M.set(r, c+1);
			do M.set(r-1, c+1);
			do M.set(r-2, c+1);
			do M.set(r-3, c+1);

			do B.setC(c+1);
		}
	}
	return ;
}

method void down(Map M , Block B)
{

    var int r; 
	var int c; 
    let r= B.getR();
    let c= B.getC();

	// verdict type 0 or 1
	// here
	
	if (type= 1)
	{
		if (r= 19)
		{
			return;
		}

		if ( M.read(r+1, c)= 0 )
		{
			do M.set(r+1, c);
			do M.reset(r-3, c);

			do B.setR(r+1);
		}
	}

	if (type= 0)
	{
		if (r= 19)
		{
			return;
		}

		if ( (M.read(r+1, c)= 0) & (M.read(r+1, c+1)= 0) & (M.read(r+1, c+2)= 0) & (M.read(r+1, c+3)= 0) )
		{
			do M.reset(r, c);
			do M.reset(r, c+1);
			do M.reset(r, c+2);
			do M.reset(r, c+3);
			do M.set(r+1, c);
			do M.set(r+1, c+1);
			do M.set(r+1, c+2);
			do M.set(r+1, c+3);

			do B.setR(r+1);
		}
	}
	return;
}


method boolean I_isBottom(Map M, Block B)
{
    var boolean isbottom;
    var int r;
    var int c;
    let r = B.getR();
    let c = B.getC();

    if (type = 0){
        if (r<19){
            if ((M.read(r+1 ,c)=1)|(M.read(r+1 ,c+1)=1)|(M.read(r+1 ,c+2)=1)|(M.read(r+1,c+3)=1)){
                let isbottom = true;
                
            }
            else{
                let isbottom = false;
            }
        }
        else{
            let isbottom = true;
        }
    }
    if (type = 1){
        if (r<19){
        if (M.read(r+1, c)=1){
            let isbottom = true;
        }
        else{
            let isbottom = false;
        }
        }
        else{
            let isbottom = true;
        }
    }
    return isbottom;
}
    
}